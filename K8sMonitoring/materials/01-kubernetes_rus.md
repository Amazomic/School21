# Kubernetes

**Kubernetes** - это мощный фреймворк для оркестрации контейнеров приложений, разработанный компанией Google. Как и docker swarm, он выполняет основные функции любого инструмента оркестрации: высокую доступность, защиту внутреннего трафика, инкапсуляцию сложной микросервисной архитектуры приложения в единую сущность и так далее. Но в чем основное отличие **Kubernetes** от **Docker Swarm**? Помимо более высокой сложности и большего количества доступных инструментов контроля контейнеров, основной особенностью **Kubernetes** является тот факт, что он является более высокоуровневым решением, чем **Docker Swarm**, и не завязан непосредственно на технологии *Docker*. Да, на данный момент docker является абсолютным лидером в сфере контейнерищации приложений, но все же это не единственная технология, и **Kubernetes** предлагает единый подход вне зависимости от инструмента контейнеризации.

## Архитектура и принципы работы Kubernetes

Концептуально кластер Kubernetes представляет собой следующую структуру:

<img src="misc/images/kubernetes.drawio.png"  width="600">

Архитектура Kubernetes включает в себя следующие основные компоненты:

*Master node* - это главный узел, который управляет всеми узлами в кластере Kubernetes. Он состоит из нескольких компонентов:

1. kube-apiserver: это компонент, который предоставляет API для управления кластером Kubernetes.
2. etcd: это хранилище ключ-значение, которое используется для хранения данных конфигурации кластера Kubernetes.
3. kube-scheduler: это компонент, который отвечает за планирование работы на узлах в кластере Kubernetes.
4. kube-controller-manager: это компонент, который управляет контроллерами, которые отвечают за выполнение операций, таких как масштабирование и восстановление после сбоев.

*Node* или *Worker node* - это узел, на котором работают контейнеры приложений. Он состоит из следующих компонентов:

1. kubelet: это компонент, который управляет контейнерами на узле и взаимодействует с kube-apiserver на главном узле.
2. kube-proxy: это компонент, который отвечает за маршрутизацию сетевых запросов к контейнерам на узле.

*Pod* - это наименьшая единица в Kubernetes, которая содержит один или несколько контейнеров приложения. *Pod* является миниальной абстракцией Kubernetes в силу того, что Kubernetes как технология стремится отойти от привязки к конкретному инструменту контейнеризации, поэтому и возникла необходимость в создании нового типа абстракции, являющегося дополнительным "контейнером для контейнера". Каждый *Pod* имеет свой IP-адрес (определяеммый динамически в момент его запуска) и совместно использует ресурсы узла, на котором он работает. Важно понимать, что при перезапуске *Pod*, его IP-адрес изменяется, так как фактически поднимается новый *Pod*.

Но существует и множество других необходимых для понимания архитектуры Kubernetes объектов, большинство из которых представлены ниже:

*Service* - это объект **Kubernetes**, который обеспечивает постоянный IP-адрес и DNS-имя для доступа к приложению внутри кластера. Он может маршрутизировать запросы к разным *Pod*'ам на основе селекторов. Более того, при реплицировании *Pod* объект *service* выступает и в роли балансировщика, распределяющего запросы между репликами. 

*Volume* - это объект **Kubernetes**, который используется для хранения данных, которые нужны контейнерам в *Pod*. Volume может быть подключен к контейнеру приложения, чтобы обеспечить доступ к данным.

*Namespace* - это объект **Kubernetes**, который используется для группировки ресурсов кластера и разделения доступа к этим ресурсам между пользователями и командами.

В **Kubernetes** реплицирование (replication) - это механизм, который позволяет создавать несколько копий одного и того же приложения и запускать их на нескольких узлах. Это обеспечивает высокую доступность приложения, а также позволяет обрабатывать большую нагрузку.

Реплика-контроллер (Replication Controller) управляет процессом создания и масштабирования реплицированных подов (replicated pods) в Kubernetes. Когда создается реплика-контроллер, он создает необходимое количество подов, указанное в спецификации контроллера. Если какой-либо под выходит из строя или удаляется, контроллер автоматически создает новый под, чтобы заменить потерянный.

Реплицированные поды имеют *метку* (label), которая помогает реплика-контроллеру управлять ими. Метки также используются для того, чтобы сервисы (services) могли определять, какие поды должны принимать трафик.

Реплика-контроллеры могут быть использованы для масштабирования приложений горизонтально, путем увеличения или уменьшения количества реплицированных подов. Это позволяет быстро реагировать на изменения в нагрузке на приложение.

В **Kubernetes** *Deployment* и *StatefulSet* это объекты, которые управляют запуском и масштабированием приложений. Оба объекта представляют собой декларативный способ определения желаемого состояния приложения и автоматического управления его жизненным циклом.

*Deployment* обеспечивает управление развертыванием (установкой) приложения в **Kubernetes**. Он описывает, как и когда необходимо создавать экземпляры приложения, а также какие обновления необходимо производить при изменении конфигурации. *Deployment* автоматически создает и управляет несколькими репликами приложения, что обеспечивает отказоустойчивость и масштабируемость.

*StatefulSet* обеспечивает управление установкой и масштабированием приложений, которые имеют состояние. Это может быть полезно, например, для баз данных, которые хранят данные на жестких дисках, и которые не могут быть просто скопированы и запущены на другом узле кластера. *StatefulSet* обеспечивает уникальные имена для каждого экземпляра приложения, сохраняет их состояние и предоставляет уникальные идентификаторы хостов для каждого экземпляра.

В обоих случаях **Kubernetes** автоматически управляет жизненным циклом приложения, масштабированием, обновлением и откатом изменений. Разработчики могут определить желаемое состояние приложения, а **Kubernetes** обеспечит, чтобы оно было достигнуто и поддерживалось в течение всего жизненного цикла приложения.

*Ingress* в **Kubernetes** — это объект, который позволяет управлять входящим трафиком в кластер. *Ingress* служит как контроллер, который определяет правила маршрутизации трафика между службами в кластере и внешним миром. Это позволяет разработчикам и администраторам управлять входящим трафиком, настраивать маршрутизацию и безопасность, а также осуществлять балансировку нагрузки. Кроме того, *Ingress* может использоваться для настройки SSL-шифрования и аутентификации клиентов. В целом, использование *Ingress* упрощает управление сетью и обеспечивает более гибкую и эффективную работу приложений в **Kubernetes**.

*ConfigMap* и *Secret* - это два механизма в Kubernetes для хранения конфигурационных данных и секретов, соответственно.

*ConfigMap* используется для хранения конфигурационных данных, которые используются приложениями в контейнерах (обычно в виде переменных окружения). Например, это могут быть параметры, которые должны быть изменены при развертывании приложения, такие как адрес базы данных или порт веб-сервера. *ConfigMap* может быть применен к любому количеству контейнеров в поде.

*Secret* используется для хранения конфиденциальной информации, такой как пароли, ключи и сертификаты. *Secret* может быть использован для любого количества контейнеров в поде. Важно отметить, что *Secret* хранится в зашифрованном виде в etcd кластера Kubernetes.

Использование *ConfigMap* и *Secret* позволяет снизить количество необходимых параметров в манифестах приложений и улучшить безопасность приложений, так как конфиденциальная информация не будет храниться в открытом виде. 

## Интерфейс командной строки kubectl

Kubectl - это клиент Kubernetes API, предоставляющий доступ к функциям окружения Kubernetes. Kubernetes API представляет из себя HTTP REST API сервер предоставляющий доступ ко всем функциям Kubernetes как к ендпоинтам для HTTP-запросов. 

### Основные команды kubectl

* config

Настройка и отображение конфигурации системы (kubeconfig)

`kubectl config view`

* apply 

Управление ресурсами Kubernetes

`kubectl apply -f <относительный путь к манифесту>`

`kubectl explain pods`

* get

Просмотри и поиск ресурсов системы

`kubectl get <название ресурса> --<параметры поиска>`

* edit, scale, delete

Редактирование конкретных ресурсов системы. Наиболее популярные команды при сопровождении системы Kubernetes

`kubectl edit <название сервиса>`

`kubectl scale --replicas=<количество сервисов> <название сервиса|путь к файлу манифеста>`

`kubectl delete <название сервиса|путь к файлу манифеста>`

* logs

Важный инструмент при отладки системы в случае возникновения ошибок. Зачастую проблема заключается не только в некорректной настройки системы оркестрации, но и в самом программном продукте, запущенном в окружении.

Для отладки программного продукта можно использовать команду 

`kubectl logs <название сервиса>`

## Манифест

Манифест в Kubernetes - это файл, который описывает желаемое состояние объекта Kubernetes. Манифест может содержать множество параметров и конфигурационных параметров для объекта, например, деплоймента, сервиса, конфигурационной карты и т. д. 

Общая структура манифеста в Kubernetes:

```yml
apiVersion: <API версия> # версия API Kubernetes, которую использует объект
kind: <Тип объекта> # тип объекта (deployment, service, configmap и т.д.)
metadata: # метаданные объекта, такие как название, метки и т.д.
  name: <Название объекта>
  labels:
    <Метки объекта>
spec: # спецификация объекта, описывающая желаемое состояние
  <Параметры объекта>
```

Например, манифест для деплоймента может выглядеть следующим образом:


```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
  labels:
    app: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-container
        image: my-image
        ports:
        - containerPort: 8080
```

В этом примере мы указываем желаемое количество реплик (3), определяем селектор для выбора подов (по метке "app: my-app") и описываем шаблон пода, который будет создан в случае необходимости. В шаблоне мы указываем название контейнера, используемый образ и порт, который будет открыт в контейнере.

Часто применяется практика разделения манифестов на различные файлы, демонстрирующее поэтапное развертывание. Например, сначала можно создать конфиграционную карту, потом секреты, а потом сервисы и т. д. 
